require(osDesign)
# require(missreg3)
require(plyr)
require(MESS)

#1.产生数据
Dat_gen <- function(n, beta, ratio){
  #没有分层 不需要numG，没有先验 不需要theta
  #n: total number of subjects in phase I
  #beta: odds ratio
  #theta: known odds ratios for x1,x2,x3 (Yaqi:no theta?)
  #p0: pre-specified probability of being selected into phase II for Y=0,G=g (Yaqi:G=g?)
  #ratio: pre-spefified number of controls relative to cases
  #(Yaqi:specified)
  
  # Phase I sample
  x1 <- rnorm(n)
  x2 <- runif(n)
  x3 <- rbinom(n, size=1, prob=0.2)
  z <- rnorm(n)
  X <- cbind(rep(1,n), x1, x2, x3, z)
  y <- rbinom(n, size=1, prob=exp(X %*% beta)/(1+exp(X %*% beta)))
  dat <- data.frame(cbind(y,x1,x2,x3,z))
  dat_case <- dat[dat$y==1, ]
  dat_con <- dat[dat$y==0, ]
  
  
  return (list(dat=dat))
}

#A. Benchmark
## Fit logistic regression to full data as benchmark ##
Dat_fullFit <- function(data){
  #data: generated by Dat_format("Benchmark")
  
  # Directly fit the logistic model 
  m <- glm(y ~ x1 + x2 + x3 + z, family=binomial, data=data)
  yhat.full <- m$fitted.values
  beta.full <- m$coefficients
  beta.var.full <- summary(m)$cov.unscaled
  X <- cbind(rep(1,nrow(data)), data$x1, data$x2, data$x3, data$z) #Design matrix
  data <- cbind(data, yhat.full)
  
  # Score for each subject: case/control
  S1_beta <- apply(cbind(X, yhat.full), 1, function(x) x[1:5]*(1-x[6]))
  S0_beta <- apply(cbind(X, yhat.full), 1, function(x) x[1:5]*(0-x[6]))
  
  # inverse of -dS/dbeta*(1/n)
  I_betabeta <- solve(t(X) %*% diag(as.vector(yhat.full*(1-yhat.full))) %*% X/n)
  
  # influence function 
  h1 <- I_betabeta %*% S1_beta
  h0 <- I_betabeta %*% S0_beta
  return(list(h1=h1, h0=h0, yhat.full=yhat.full, beta.full=beta.full, beta.var.full=diag(beta.var.full)))
}

############################################################
# Calculate auc by fitting the logistic regression model #
Dat_auc_full <- function(data, fullFit_list){
  #fullFit_list: generated by Dat_fullFit(data)
  h1 <- fullFit_list$h1
  h0 <- fullFit_list$h0
  yhat.full <- fullFit_list$yhat.full
  beta.full <- fullFit_list$beta.full
  
  #calculate auc
  denom_tpr.full <- sum(yhat.full)
  denom_fpr.full <- sum(1-yhat.full)
  #c <- c(seq(0, 1, by=0.01)*max(yhat.full),1)
  c <- seq(0, 1, by=0.05)  
  num_tpr.full <- numeric(length(c))
  num_fpr.full <- numeric(length(c))
  for (j in 1:length(c)){
    ind <- (yhat.full>=c[j])
    num_tpr.full[j] <- sum(yhat.full[ind==1])
    num_fpr.full[j] <- sum((1-yhat.full)[ind==1])
  }
  tpr.full <- num_tpr.full/denom_tpr.full
  fpr.full <- num_fpr.full/denom_fpr.full
  plot(fpr.full, tpr.full,type="b")
  auc <- auc(fpr.full, tpr.full)
  
  # numerical method for dFPR/dbeta and dTPR/dbeta as a function of c
  dFPR_beta <- matrix(0, nrow=numbeta, ncol=length(c))
  dTPR_beta <- matrix(0, nrow=numbeta, ncol=length(c))
  yfit1 <- numeric(nrow(data))
  yfit2 <- numeric(nrow(data))
  X <- cbind(rep(1,nrow(data)), data$x1, data$x2, data$x3, data$z) #Design matrix
  for (i in 1:numbeta){
    tmp1 <- beta.full
    tmp2 <- beta.full
    tmp1[i] <- beta.full[i] + epsilon_beta[i]
    tmp2[i] <- beta.full[i] - epsilon_beta[i]
    yfit1 <- exp(X %*% tmp1)/(1 + exp(X %*% tmp1))
    yfit2 <-  exp(X %*% tmp2)/(1 + exp(X %*% tmp2))
    num1_tpr <- 0
    num2_tpr <- 0
    num1_fpr <- 0
    num2_fpr <- 0
    denom1_tpr <- sum(yfit1)
    denom2_tpr <- sum(yfit2)
    denom1_fpr <- sum(1-yfit1)
    denom2_fpr <- sum(1-yfit2)
    
    for (j in 1:length(c)){
      ind1 <- (yfit1>=c[j])
      ind2 <- (yfit2>=c[j])
      num1_tpr <- sum(yfit1[ind1==1])
      num2_tpr <- sum(yfit2[ind2==1])
      num1_fpr <- sum((1-yfit1)[ind1==1])
      num2_fpr <- sum((1-yfit2)[ind2==1])
      dTPR_beta[i,j] <- (num1_tpr/denom1_tpr-num2_tpr/denom2_tpr)/(2*epsilon_beta[i])
      dFPR_beta[i,j] <- (num1_fpr/denom1_fpr-num2_fpr/denom2_fpr)/(2*epsilon_beta[i])
    }
  }
  
  # calculate influence function for TPR/FPR as a function of c
  mat_tpr.full <- matrix(0, nrow=nrow(data), ncol=length(c))
  mat_fpr.full <- matrix(0, nrow=nrow(data), ncol=length(c))
  for (j in 1:length(c)){
    ind <- (yhat.full>=c[j])
    mat_tpr.full[,j] <- yhat.full*(ind-tpr.full[j])/(denom_tpr.full/n)
    mat_fpr.full[,j] <- (1-yhat.full)*(ind-fpr.full[j])/(denom_fpr.full/n)
  }
  
  # calculate the influence function for tpr/fpr
  h1_tpr <- t(h1) %*% dTPR_beta + mat_tpr.full
  h0_tpr <- t(h0) %*% dTPR_beta + mat_tpr.full
  h1_fpr <- t(h1) %*% dFPR_beta + mat_fpr.full
  h0_fpr <- t(h0) %*% dFPR_beta + mat_fpr.full
  
  #calcualte influence function for auc
  h1_auc <- 0-apply(h1_fpr, 1, function(x) auc(tpr.full, x))+apply(h1_tpr, 1, function(x) auc(fpr.full, x))
  h0_auc <- 0-apply(h0_fpr, 1, function(x) auc(tpr.full, x))+apply(h0_tpr, 1, function(x) auc(fpr.full, x))
  
  emp_cov_auc <- sum((h1_auc)^2*data$y, (h0_auc)^2*(1-data$y))
  var_auc <- emp_cov_auc/n^2
  return(list(auc=auc, var_auc=var_auc))
}

#######Main Code
set.seed(123)
p0 <- c()

n <- 3000
beta <- log(c(0.03,0.6,1.6,0.6,1.5))
numbeta <- length(beta)

# Threshold for calculating pcf #
q <- 0.2
# Threshold for calculating pnf # 
p <- 0.9 #Yaqi:p=0.3?
# Possible threshold values for ROC curve
cc <- seq(0, 1, by=0.01) 

epsilon_beta <- abs(beta)/5

K=3
auc1=c();aucv=c()
for(k in 1:K)
{
  dat_list <- Dat_gen(n, beta, ratio)
  data.full <- dat_list$dat
  #data=data.full
  #fulldata_list=fullFit_list
  fullFit_list <- Dat_fullFit(data.full)
  
  auc_list_full <- Dat_auc_full(data.full, fullFit_list)
  auc1[k]=auc_list_full$auc
  aucv[k]=auc_list_full$var_auc
}
mean(auc1)
sqrt(mean(aucv))
sd(auc1)
